import pandas as pd
import glob
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
from preprocessing_data import data
import pandas as pd
from sklearn.model_selection import train_test_split

flow_graph = nx.DiGraph()
source_ips = data["Source IP"].unique()
destination_ips = data["Destination IP"].unique()
end_point = np.union1d(source_ips, destination_ips)

end_point_list = end_point.tolist()

flow_graph.add_nodes_from(end_point_list)

edges_list = data[["Source IP", "Destination IP"]].values.tolist()

flow_graph.add_edges_from(edges_list)

i = 0
for edge in flow_graph.edges():
    src_ip = edge[0]
    dst_ip = edge[1]

    # Lọc dữ liệu theo cạnh hiện tại
    edge_data = data[(data["Source IP"] == src_ip) & (data["Destination IP"] == dst_ip)]

    if not edge_data.empty:
        edge_vector = []
        for column in edge_data.columns:
            if column not in [
                "Protocol",
                "Source IP",
                "Destination IP",
                "Source Port",
                "Destination Port",
                "Timestamp",
                "Label",
            ]:
                values = edge_data[column]
                stats = []

                if not np.isnan(np.nanmean(values)):
                    stats.append(np.nanmean(values))
                else:
                    stats.append(-1)
                if not np.isnan(np.nanstd(values)):
                    stats.append(np.nanstd(values))
                else:
                    stats.append(-1)
                if not np.isnan(values.skew()):
                    stats.append(values.skew())
                else:
                    stats.append(-1)
                if not np.isnan(values.kurtosis()):
                    stats.append(values.kurtosis())
                else:
                    stats.append(-1)
                if not np.isnan(np.nanmedian(values)):
                    stats.append(np.nanmedian(values))
                else:
                    stats.append(-1)

                edge_vector.extend(stats)

        flow_graph[src_ip][dst_ip]["attr"] = np.array(edge_vector)

data_list = []

for edge in flow_graph.edges():
    src_ip = edge[0]
    dst_ip = edge[1]

    if "attr" in flow_graph[src_ip][dst_ip]:
        attr_vector = flow_graph[src_ip][dst_ip]["attr"]

        # Lấy label từ dữ liệu gốc
        label = data[
            (data["Source IP"] == src_ip) & (data["Destination IP"] == dst_ip)
        ]["Label"].values[0]

        # Tạo một dictionary mới để lưu dữ liệu
        attr_dict = {f"attr_{i}": val for i, val in enumerate(attr_vector)}

        # Tạo một dictionary chứa dữ liệu từng dòng
        row_data = {
            "src_ip": src_ip,
            "dst_ip": dst_ip,
            "label": label,
            **attr_dict,  # Thêm các trường từ attr_dict vào dữ liệu
        }
        data_list.append(row_data)

# Tạo DataFrame từ data_list
columns = ["src_ip", "dst_ip", "label"] + [f"attr_{i}" for i in range(len(attr_vector))]
df = pd.DataFrame(data_list, columns=columns)
print(df)

# Chọn 100 mẫu cho mỗi nhãn làm tập huấn luyện, phần còn lại là tập test
train_data = df.groupby("label").apply(lambda x: x.sample(n=100)).reset_index(drop=True)
test_data = df.drop(train_data.index)

# Tách các feature và nhãn cho cả tập huấn luyện và tập test
X_train = train_data.drop(["label", "src_ip", "dst_ip"], axis=1)
y_train = train_data["label"]
X_test = test_data.drop(["label", "src_ip", "dst_ip"], axis=1)
y_test = test_data["label"]

# Kiểm tra kích thước của tập huấn luyện và tập test
print("Kích thước tập huấn luyện:", len(train_data))
print("Kích thước tập test:", len(test_data))


def extract_structural_features(G):
    # Global Features
    global_clustering_coefficient = nx.average_clustering(G)
    assortativity = nx.degree_assortativity_coefficient(G)

    # Local Node Features
    degrees = dict(G.degree())
    two_hop_neighbors = {}
    clustering_coeffs = nx.clustering(G)
    avg_neighbor_degrees = {}
    avg_neighbor_clustering_coeffs = {}
    edges_in_egonet = {}
    edges_leaving_egonet = {}
    betweenness_centrality = nx.betweenness_centrality(G)

    for node in G.nodes():
        two_hop_neighbors[node] = sum(
            len(set(G.neighbors(neighbor))) - 1 for neighbor in G.neighbors(node)
        )
        avg_neighbor_degrees[node] = np.mean(
            [degrees[neighbor] for neighbor in G.neighbors(node)]
        )
        avg_neighbor_clustering_coeffs[node] = np.mean(
            [clustering_coeffs[neighbor] for neighbor in G.neighbors(node)]
        )
        edges_in_egonet[node] = len(G.subgraph(G.neighbors(node)).edges())
        edges_leaving_egonet[node] = len(
            set(G.neighbors(node)) - set(G.subgraph(G.neighbors(node)).nodes())
        )

    # Concatenate all features into a 40-dimensional feature vector
    feature_vector = np.array(
        [
            global_clustering_coefficient,
            assortativity,
            *list(degrees.values()),
            *list(two_hop_neighbors.values()),
            *list(clustering_coeffs.values()),
            *list(avg_neighbor_degrees.values()),
            *list(avg_neighbor_clustering_coeffs.values()),
            *list(edges_in_egonet.values()),
            *list(edges_leaving_egonet.values()),
            *list(betweenness_centrality.values()),
        ]
    )

    return feature_vector


structural_features = extract_structural_features(flow_graph)

# print(flow_graph.nodes())
node_labels = dict(zip(end_point_list, data["Label"].tolist()))


# Create a mapping of unique labels to colors
unique_labels = data["Label"].unique()
label_color_map = {
    label: np.random.rand(
        3,
    )
    for label in unique_labels
}  # Random color assignment

# Create a list of colors for each node based on its label
node_colors = [label_color_map[node_labels[node]] for node in flow_graph.nodes()]

# Visualize the graph
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection="3d")
pos = nx.spring_layout(flow_graph, dim=3)

for node in flow_graph.nodes():
    label = node_labels[node]
    ax.scatter(
        pos[node][0], pos[node][1], pos[node][2], color=label_color_map[label], s=50
    )

for edge in flow_graph.edges():
    ax.plot(
        [pos[edge[0]][0], pos[edge[1]][0]],
        [pos[edge[0]][1], pos[edge[1]][1]],
        [pos[edge[0]][2], pos[edge[1]][2]],
        color="black",
    )

# Set labels and display
ax.set_xlabel("X-axis")
ax.set_ylabel("Y-axis")
ax.set_zlabel("Z-axis")
# plt.show()
